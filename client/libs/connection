--Server connection stuff:

-- local function getNewConnectionStuff()
-- 	local public = {
-- 	    base = 11,
-- 	    primeMod = 625210769
-- 	}
-- 	loglib.debug("Connection: Generating secret/public keys")
-- 	return {
-- 		mySecret = math.random(100000, 999999)
-- 		myPublic = modexp(public.base, mySecret, public.primeMod),
-- 		public = public
-- 	}
-- end

function modexp(base, exponent, modulo)
    local remainder = base
    for i = 1, exponent-1 do
        remainder = remainder * remainder
        if remainder >= modulo then
                remainder = remainder % modulo
        end
    end
    return remainder
end

function connectToServer(ID, timeout)
	loglib.info("Connecting to server with ID:"..ID)
	rednet.send(ID, "init_connection", "far:keys")
	local response = assert( waitForMessage(ID, "far:keys", timeout) )
	assert(response.message == "ok:generate_keys" and response.public_primeMod and response.public_base and response.public_key)
	loglib.debug("Connection: Generating keys")
	mySecret = math.random(100000, 999999)
	myPublic = modexp(response.public_base, mySecret, response.public_primeMod)
	loglib.debug("Connection: Sending keys")
	rednet.send(ID, 
		{
			message = "ok:exch_public",
			public_key = myPublic
		}, "far:keys"
	)
	loglib.debug("Connection: Generating shared key")
	local sharedKey = modexp(response.public_key, mySecret, response.public_primeMod)
	loglib.info("Connection established!")
end

function waitForMessage(ID, protocol, timeout)
	while true do
		local senderId, message, protocol = rednet.receive(protocol, timeout)
		if not senderId then loglib.error("Connection with server ID:"..ID.." timed out.")
			break
		end
		if senderId == ID then
			return message
		end
	end
end



local random = math.random
local key = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31}

local function gen_nonce(size)
  local n = {}
  for i = 1, size do n[#n+1] = random(0, 255) end
  return n
end

local function encrypt(msg)
  local nonce = gen_nonce(12)
  local ctx = encryption.crypt(msg, key, nonce)
  return { nonce, ctx }
end

local function decrypt(msg)
  local nonce = msg[1]
  local ctx = msg[2]
  return encryption.crypt(ctx, key, nonce)
end