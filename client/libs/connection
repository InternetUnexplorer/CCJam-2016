--Server connection stuff:

-- local function getNewConnectionStuff()
-- 	local public = {
-- 	    base = 11,
-- 	    primeMod = 625210769
-- 	}
-- 	loglib.debug("Connection: Generating secret/public keys")
-- 	return {
-- 		mySecret = math.random(100000, 999999)
-- 		myPublic = modexp(public.base, mySecret, public.primeMod),
-- 		public = public
-- 	}
-- end

function modexp(base, exponent, modulo)
    local remainder = base
    for i = 1, exponent-1 do
        remainder = remainder * remainder
        if remainder >= modulo then
                remainder = remainder % modulo
        end
    end
    return remainder
end

function connectToServer(ID, timeout)
	loglib.info("Connecting to server with ID:"..ID)
	rednet.send(ID, "init_connection", "far:keys")
	local response = assert( waitForMessage(ID, "far:keys", timeout) )
	assert(response.message == "ok:generate_keys" and response.public_primeMod and response.public_base and response.public_key1 and response.public_key2)
	loglib.debug("Connection: Generating keys")
	mySecret1 = math.random(100000, 999999)
	myPublic1 = modexp(response.public_base, mySecret1, response.public_primeMod)
	mySecret2 = math.random(100000, 999999)
	myPublic2 = modexp(response.public_base, mySecret2, response.public_primeMod)
	loglib.debug("Connection: Sending keys")
	rednet.send(ID, 
		{
			message = "ok:exch_public",
			public_key1 = myPublic1,
			public_key2 = myPublic2
		}, "far:keys"
	)
	loglib.debug("Connection: Generating shared key")
	local sharedKey = (modexp(response.public_key1, mySecret1, response.public_primeMod)..""..modexp(response.public_key2, mySecret2, response.public_primeMod)):sub(0, 16)
	loglib.info("Connection established!")
	local key = {}
	for i = 1, 16 do
		key[i] = tonumber(sharedKey:sub(i, i))
	end
end

function waitForMessage(ID, protocol, timeout)
	while true do
		local senderId, message, protocol = rednet.receive(protocol, timeout)
		if not senderId then loglib.error("Connection with server ID:"..ID.." timed out.")
			break
		end
		if senderId == ID then
			return message
		end
	end
end



local random = math.random
function gen_nonce(size)
  local n = {}
  for i = 1, size do n[#n+1] = random(0, 255) end
  return n
end

function encrypt(msg, key)
  local nonce = gen_nonce(12)
  local ctx = encryption.crypt(msg, key, nonce)
  return { nonce, ctx }
end

function decrypt(msg, key)
  local nonce = msg[1]
  local ctx = msg[2]
  return encryption.crypt(ctx, key, nonce)
end