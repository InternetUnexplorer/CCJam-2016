--Server connection stuff:

connections = {}

function handle(ID, message, protocol, timeout)
	if protocol == "far:init_connection" and message == "init_connection" then
		handleIncomingConnection(ID, timeout)
	end
end

function handleIncomingConnection(ID, timeout)
	log.debug("Incoming connection from /"..ID)
	local connection = {
		client_id = ID,
		authenticated = false,
		session_id = #connections + 1,
		timeout = timeout
	}
	connections[#connections + 1] = connection
	local ok, err = pcall(function(timeout)
		rednet.send(ID, 
			{
				sessionId = connection.session_id,
				message = "ok:request_credentials"
			}, "far:init_connection"
		)
		response = assert(waitForMessage(ID, "far:init_connection:"..connection.session_id, timeout * 10))
		assert(response.username and response.passwd)
		if loadAccounts()[response.username] ~= response.passwd then
			rednet.send(ID, 
				{
					message = "err:bad_auth"
				}, "far:init_connection:"..connection.session_id
			)
			return
		end
		rednet.send(ID, 
			{
				message = "ok:get_client_details"
			}, "far:init_connection:"..connection.session_id
		)
		response = assert(waitForMessage(ID, "far:init_connection:"..connection.session_id, timeout))
		assert (response.is_color ~= nil and response.size_x and response.size_y)
		if term.isColor() and response.is_color then
			connection.is_color = true
		else
			connection.is_color = false
		end
		connection.size_x = response.size_x
		connection.size_y = response.size_y
		rednet.send(ID, 
			{
				message = "ok:welcome"
			}, "far:init_connection:"..connection.session_id
		)
	end
	, timeout)
	if not ok then
		local s, i = err:find(":")
		if i then
			err = err:sub(i + 1)
		end
		log.warn("Connection failed:\n"..err)
		rednet.send(ID, 
			{
				message = "err:response_err"
			}, "far:init_connection:"..connection.session_id
		)
		return
	end
	connection.authenticated = true
	log.info("Launching shell session for /"..ID)
	launchTermSession(connection)
end

function waitForMessage(ID, protocol, timeout)
	while true do
		local senderId, message, protocol = rednet.receive(protocol, timeout)
		if not senderId then --error("Connection with client /"..ID.." timed out.")
			break
		end
		if senderId == ID then
			return message
		end
	end
end

function loadAccounts()
	local ok, accounts = pcall(json.decodeFromFile, _G._FAR_SERVER_ROOT.."accounts.json")
	if not (accounts and ok) then
		log.info("accounts.json could not be loaded, making a new one")
		local f = fs.open(localDir.."accounts.json", "w")
		f.writeLine(json.encodePretty({}))
		f.close()
		return {}
	end
	return accounts
end

function launchTermSession(connection)
	local faketerm = {}
	local ok, err = loadfile( _G._FAR_SERVER_ROOT.."libs/hooks/term" )
	if ok then
		local ok, err = pcall(ok, connection)
		if not ok then
			log.error("Error creating shell session:\n"..err)
			return false
		end
		faketerm = err
	else
		log.error("Error creating shell session:\n"..err)
		return false
	end
	term.redirect(faketerm)
	--Make the utility functions:
	connection.sendUpdate = function ( data )
		rednet.send(
			connection.client_id,
			data,
			"far:su:"..connection.session_id
		)
	end

	connection.getResp = function ( req )
		rednet.send(
			connection.client_id,
			data,
			"far:gr:"..connection.session_id
		)
		response = assert(waitForMessage(connection.client_id, "far:sr:"..connection.session_id, connection.timeout), "Timed out.")
		assert( response.data, "Malformed response" )
		return response.data
	end

	os.run( _ENV, "/rom/programs/shell" )
	return true
end