--Server connection stuff:

connections = {}

function handle(ID, message, protocol, timeout)
	if protocol == "far:init_connection" and message == "init_connection" then
		handleIncomingConnection(ID, timeout)
	end
end

function handleIncomingConnection(ID, timeout)
	log.debug("Incoming connection from /"..ID)
	local connection = {
		client_id = ID,
		authenticated = false,
		session_id = #connections + 1
	}
	connections[#connections + 1] = connection
	local ok, err = pcall(function(timeout)
		rednet.send(ID, 
			{
				sessionId = connection.session_id,
				message = "ok:request_credentials"
			}, "far:init_connection"
		)
		response = assert(waitForMessage(ID, "far:init_connection:"..connection.session_id, timeout * 10))
		assert(response.username and response.passwd)
		if loadAccounts()[response.username] == response.passwd then
			rednet.send(ID, 
				{
					message = "ok:welcome"
				}, "far:init_connection:"..connection.session_id
			)
		else
			rednet.send(ID, 
				{
					message = "err:bad_auth"
				}, "far:init_connection:"..connection.session_id
			)
			return
		end
	end
	, timeout)
	if not ok then
		local s, i = err:find(":")
		if i then
			err = err:sub(i + 1)
		end
		log.warn("Connection failed:\n"..err)
		rednet.send(ID, 
			{
				message = "err:response_err"
			}, "far:init_connection:"..connection.session_id
		)
		return
	end
	connection.authenticated = true
	log.info("Launching shell session for /"..ID)
	launchTermSession(connection)
end

function waitForMessage(ID, protocol, timeout)
	while true do
		local senderId, message, protocol = rednet.receive(protocol, timeout)
		if not senderId then error("Connection with client /"..ID.." timed out.")
			break
		end
		if senderId == ID then
			return message
		end
	end
end

function loadAccounts()
	local ok, accounts = pcall(json.decodeFromFile, _G._FAR_SERVER_ROOT.."accounts.json")
	if not (accounts and ok) then
		log.info("accounts.json could not be loaded, making a new one")
		local f = fs.open(localDir.."accounts.json", "w")
		f.writeLine(json.encodePretty({}))
		f.close()
		return {}
	end
	return accounts
end

function wrap(f, ...)
      local args = { ... }
      return function() f(unpack(args)) end
end

function launchTermSession(connection)
	local faketerm = {}
	local fakeEnv = shallowcopy(_G)
	setmetatable( fakeEnv, getmetatable( _G ) )
	local ok, err = loadfile( _G._FAR_SERVER_ROOT.."libs/hooks/term" )
	-- setfenv( fakeEnv.term.native, fakeEnv )
	if ok then
		local ok, err = pcall(ok, term)
		if not ok then
			log.error("Error creating shell session:\n"..err)
			return false
		end
		faketerm = err
	else
		log.error("Error creating shell session:\n"..err)
		return false
	end
	fakeEnv.term = faketerm
	local mfunc = os.run
	fakeEnv.os.run = function( env, ... )
		for k,v in pairs(env) do fakeEnv[k] = v end
		mfunc(fakeEnv, ... )
	end
	fakeEnv.os.run(fakeEnv, "/rom/programs/shell")
end

function shallowcopy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in pairs(orig) do
            copy[orig_key] = orig_value
        end
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end