------------------------------------------------------------------------
_GLOBAL_TIMEOUT = 5
------------------------------------------------------------------------
function loadAccounts()
	local ok, accounts = pcall(json.decodeFromFile, localDir.."accounts.json")
	if not (accounts and ok) then
		log.info("accounts.json could not be loaded, making a new one")
		local f = fs.open(localDir.."accounts.json", "w")
		f.writeLine(json.encodePretty({}))
		f.close()
		return {}
	end
	return accounts
end

function storeAccounts(accounts)
	local f = fs.open(localDir.."accounts.json", "w")
	f.writeLine(json.encodePretty(accounts))
	f.close()
end

function addAccount(username)
	local accounts = loadAccounts()
	if accounts[username] then
		printError("A user with that name already exists.")
		return
	end
	write("Enter a password: ")
	local pass1 = read("*")
	write("Confirm password: ")
	local pass2 = read("*")
	if pass1 ~= pass2 then
		printError("Passwords do not match!")
		return
	end
	accounts[username] = hashpassword.sha1(pass1)
	storeAccounts(accounts)
	print("User created.")
end

function removeAccount(username)
	local accounts = loadAccounts()
	if not accounts[username] then
		printError("User does not exist.")
		return
	end
	accounts[username] = nil
	storeAccounts(accounts)
	print("User removed.")
end

function changeAccountPassword(name, accounts)
	local accounts = loadAccounts()
	if not accounts[username] then
		printError("User does not exist.")
		return
	end
	write("Enter a password: ")
	local pass1 = read("*")
	write("Confirm password: ")
	local pass2 = read("*")
	if pass1 ~= pass2 then
		printError("Passwords do not match!")
		return
	end
	accounts[username] = hashpassword.sha1(pass1)
	storeAccounts(accounts)
	print("Password changed.")
end

function startServer()
	if not _G.FAR_SERVER._FAR_SERVER_RUNNING then
		local ok, err = pcall( runServer )
		if not ok then
			log.fatal(err)
			log.fatal("--- Server Crashed ---")
		end
		log.shutdown()
	else
		printError("Server is already running!")
	end
end

function runServer()
	_G.FAR_SERVER._FAR_SERVER_RUNNING = multishell.getCurrent()
	_G.FAR_SERVER._KEEP_SERVER_ALIVE = true
	multishell.setTitle(_G.FAR_SERVER._FAR_SERVER_RUNNING, "FAR Server - Starting")
	log.init(localDir.."logs/")
	log.info("Server starting...")
	local accounts = loadAccounts()
	log.info("Starting connection listener...")
	rednet.open( "top" )
	multishell.setTitle(_G.FAR_SERVER._FAR_SERVER_RUNNING, "FAR Server - Running")
	while _G.FAR_SERVER._KEEP_SERVER_ALIVE do
		local senderId, message, protocol
		parallel.waitForAny(
			function()
				senderId, message, protocol = rednet.receive(_GLOBAL_TIMEOUT)
			end,
			wrap(os.pullEvent, "_KILL_FAR_SERVER")
		)
		if senderId then
			connection.handle(senderId, message, protocol)
		end
	end
end

function serverStatus()
	if not (_G.FAR_SERVER._FAR_SERVER_RUNNING and pcall(multishell.setFocus, _G.FAR_SERVER._FAR_SERVER_RUNNING)) then
		print("Server is not running.")
	end
end

function stopServer()
	print("Stopping server...")
	_G.FAR_SERVER._KEEP_SERVER_ALIVE = false
	local originalTime = os.clock()
	os.queueEvent( "_KILL_FAR_SERVER" )
	while _G.FAR_SERVER._FAR_SERVER_RUNNING and ((os.clock() - originalTime) < _GLOBAL_TIMEOUT) do
		sleep(0.05)
	end
	print("Server stopped.")
end

function testInstall(requiredAPIs)
	for i = 1, #requiredAPIs do
		if not os.loadAPI(localDir.."libs/"..requiredAPIs[i]) then
			printError("Missing required dependency "..requiredAPIs[i])
	    	return false
		end
	end
	return true
end
function wrap(f, ...)
      local args = { ... }
      return function() f(unpack(args)) end
end

function printUsage( modifier )
	print( "Usage:" )
	if modifier == "service" or not modifier then
		print("server service start")
		print(" - Starts the server")
		print("server service stop")
		print(" - Stops the server")
		print("server service status")
		print(" - Shows the status of the server")
		print("server service restart")
		print(" - Restarts the server")
	end
	if modifier == "users" or not modifier then
		print("server users add <NAME>")
		print(" - Adds a user account to the server")
		print("server users passwd <NAME>")
		print(" - Changes the password for user <NAME>")
		print("server users remove <NAME>")
		print(" - Removes a user account from the server")
	end
end

localDir = "/"..fs.getDir(shell.getRunningProgram()).."/"
requiredAPIs = {
	"override",
	"log",
	"connection",
	"json",
	"hashpassword"
}
--Test the installation first
if not testInstall(requiredAPIs) then
	return
end
------------------------------------------------------------------------
if not _G.FAR_SERVER then
	_G.FAR_SERVER = {}
end
local args = {...}
if #args < 2 then
	printError( "Not enough arguments" )
	printUsage()
	return
end

if args[1] == "service" then
	if args[2] == "start" then
		startServer()
	elseif args[2] == "status" then
		serverStatus()
	elseif args[2] == "stop" then
		stopServer()
	elseif args[2] == "restart" then
		stopServer()
		startServer()
	else
		printError("Unknown action '"..args[2].."'")
		printUsage("service")
	end
elseif args[1] == "users" then
	if #args < 3 then
		printError( "Not enough arguments" )
		printUsage("users")
		return
	end
	if args[2] == "add" then
		addAccount(args[3])
	elseif args[2] == "passwd" then
		changeAccountPassword(args[3])
	elseif args[2] == "remove" then
		removeAccount(args[3])
	else
		printError("Unknown action '"..args[2].."'")
		printUsage("users")
	end
else
	printUsage()
end
------------------------------------------------------------------------
------------------------------------------------------------------------
if not _G.FAR_SERVER._KEEP_SERVER_ALIVE then
	for i = 1, #requiredAPIs do
		pcall(os.unloadAPI, requiredAPIs[i])
	end
end
------------------------------------------------------------------------
_G.FAR_SERVER._FAR_SERVER_RUNNING = false